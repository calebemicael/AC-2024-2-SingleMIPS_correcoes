$date
	Wed Apr  9 14:28:19 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbenchProcessador $end
$var wire 32 ! pc [31:0] $end
$var wire 32 " instrucao [31:0] $end
$var wire 1 # Zero $end
$var wire 32 $ ALUResult [31:0] $end
$var reg 1 % clk $end
$var reg 1 & reset $end
$scope module uut $end
$var wire 1 % clk $end
$var wire 1 & reset $end
$var wire 32 ' writeData [31:0] $end
$var wire 32 ( sinalImediato [31:0] $end
$var wire 32 ) readdata2 [31:0] $end
$var wire 32 * readdata1 [31:0] $end
$var wire 32 + readData [31:0] $end
$var wire 32 , proxPC [31:0] $end
$var wire 32 - pc_add4 [31:0] $end
$var wire 32 . pc [31:0] $end
$var wire 32 / jump_addr [31:0] $end
$var wire 32 0 instrucao [31:0] $end
$var wire 32 1 entrada2ALU [31:0] $end
$var wire 32 2 branch_add [31:0] $end
$var wire 1 # Zero $end
$var wire 1 3 RegWrite $end
$var wire 5 4 RegDst_out [4:0] $end
$var wire 1 5 RegDst $end
$var wire 1 6 MemtoReg $end
$var wire 1 7 MemWrite $end
$var wire 1 8 MemRead $end
$var wire 1 9 Jump $end
$var wire 1 : Branch $end
$var wire 1 ; ALUSrc $end
$var wire 32 < ALUResult [31:0] $end
$var wire 2 = ALUOp [1:0] $end
$var wire 4 > ALUControl [3:0] $end
$var reg 32 ? pc_reg [31:0] $end
$scope module MemoriaDeDados $end
$var wire 1 % clk $end
$var wire 32 @ writeData [31:0] $end
$var wire 32 A readData [31:0] $end
$var wire 32 B address [31:0] $end
$var wire 1 7 MemWrite $end
$var wire 1 8 MemRead $end
$var integer 32 C i [31:0] $end
$upscope $end
$scope module UnidadeDeControle $end
$var wire 6 D opcode [5:0] $end
$var reg 2 E ALUOp [1:0] $end
$var reg 1 ; ALUSrc $end
$var reg 1 : Branch $end
$var reg 1 9 Jump $end
$var reg 1 8 MemRead $end
$var reg 1 7 MemWrite $end
$var reg 1 6 MemtoReg $end
$var reg 1 5 RegDst $end
$var reg 1 3 RegWrite $end
$upscope $end
$scope module alu $end
$var wire 32 F B [31:0] $end
$var wire 4 G ALUOperation [3:0] $end
$var wire 32 H A [31:0] $end
$var reg 32 I ALUResult [31:0] $end
$var reg 1 # Zero $end
$upscope $end
$scope module controlALU $end
$var wire 6 J funct [5:0] $end
$var wire 2 K opALU [1:0] $end
$var reg 4 L ALUcontrol [3:0] $end
$upscope $end
$scope module fetchUnit $end
$var wire 1 % clk $end
$var wire 1 & reset $end
$var wire 32 M pc_incrementado [31:0] $end
$var wire 32 N instrucao [31:0] $end
$var reg 32 O pc [31:0] $end
$scope module memoria $end
$var wire 32 P addr [31:0] $end
$var wire 32 Q instrucao [31:0] $end
$var integer 32 R i [31:0] $end
$upscope $end
$scope module somador $end
$var wire 32 S in [31:0] $end
$var wire 32 T out [31:0] $end
$upscope $end
$upscope $end
$scope module muxALUSrc $end
$var wire 1 ; ALUSrc $end
$var wire 32 U sinalImediato [31:0] $end
$var wire 32 V rt [31:0] $end
$var reg 32 W entrada2ALU [31:0] $end
$upscope $end
$scope module muxMemtoReg $end
$var wire 32 X ALU_result [31:0] $end
$var wire 1 6 memtoReg $end
$var wire 32 Y readData [31:0] $end
$var wire 32 Z writeData [31:0] $end
$upscope $end
$scope module muxPCSrc $end
$var wire 1 : Branch $end
$var wire 1 9 Jump $end
$var wire 32 [ branch_add [31:0] $end
$var wire 32 \ jump_addr [31:0] $end
$var wire 32 ] pc_add4 [31:0] $end
$var wire 32 ^ proxPC [31:0] $end
$upscope $end
$scope module muxRegdst $end
$var wire 1 5 RegDst $end
$var wire 5 _ rd [4:0] $end
$var wire 5 ` rt [4:0] $end
$var wire 5 a RegDst_out [4:0] $end
$upscope $end
$scope module registradores $end
$var wire 32 b ReadData1 [31:0] $end
$var wire 32 c ReadData2 [31:0] $end
$var wire 5 d ReadRegister1 [4:0] $end
$var wire 5 e ReadRegister2 [4:0] $end
$var wire 1 3 RegWrite $end
$var wire 32 f WriteData [31:0] $end
$var wire 5 g WriteRegister [4:0] $end
$var wire 1 % clk $end
$var wire 1 & reset $end
$var integer 32 h i [31:0] $end
$upscope $end
$scope module sinal $end
$var wire 16 i in [15:0] $end
$var wire 32 j out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b10000 j
b10000 i
b100000 h
b1000 g
b0 f
b1000 e
b0 d
b0 c
b0 b
b1000 a
b1000 `
b0 _
b100 ^
b100 ]
b1000000000000001000000 \
b1000100 [
b0 Z
b0 Y
b10000 X
b10000 W
b0 V
b10000 U
b100 T
b0 S
b10100 R
b10001100000010000000000000010000 Q
b0 P
b0 O
b10001100000010000000000000010000 N
b100 M
b10 L
b0 K
b10000 J
b10000 I
b0 H
b10 G
b10000 F
b0 E
b100011 D
b100000000 C
b10000 B
b0 A
b0 @
b0 ?
b10 >
b0 =
b10000 <
1;
0:
09
18
07
16
05
b1000 4
13
b1000100 2
b10000 1
b10001100000010000000000000010000 0
b1000000000000001000000 /
b0 .
b100 -
b100 ,
b0 +
b0 *
b0 )
b10000 (
b0 '
1&
0%
b10000 $
0#
b10001100000010000000000000010000 "
b0 !
$end
#5
b100000 h
1%
#10
0%
#15
b100000 h
1%
#20
0%
0&
#25
b10100 $
b10100 <
b10100 B
b10100 I
b10100 X
b10100 1
b10100 F
b10100 W
b1001 4
b1001 a
b1001 g
b1000 ,
b1000 ^
b1001000000000001010000 /
b1001000000000001010000 \
b10100 J
b10100 (
b10100 U
b10100 j
b10100 i
b1001 `
b1001 e
b10001100000010010000000000010100 "
b10001100000010010000000000010100 0
b10001100000010010000000000010100 N
b10001100000010010000000000010100 Q
b1011000 2
b1011000 [
b1000 -
b1000 ]
b100 !
b100 .
b100 ?
b1000 M
b1000 T
b100 O
b100 P
b100 S
1%
#30
0%
#35
b101 $
b101 <
b101 B
b101 I
b101 X
b101 1
b101 F
b101 W
b1010 4
b1010 a
b1010 g
b1010000000000000010100 /
b1010000000000000010100 \
b101 J
b101 (
b101 U
b101 j
b101 i
b1010 `
b1010 e
b1100 ,
b1100 ^
b10001100000010100000000000000101 "
b10001100000010100000000000000101 0
b10001100000010100000000000000101 N
b10001100000010100000000000000101 Q
b1100 M
b1100 T
b1000 O
b1000 P
b1000 S
b100000 2
b100000 [
b1100 -
b1100 ]
b1000 !
b1000 .
b1000 ?
1%
#40
0%
#45
1#
b0 $
b0 <
b0 B
b0 I
b0 X
b0 '
b0 Z
b0 f
b0 >
b0 G
b0 L
b0 1
b0 F
b0 W
b0 4
b0 a
b0 g
b10 =
b10 E
b10 K
08
06
0;
15
b10000 ,
b10000 ^
b100001001000000000000000000 /
b100001001000000000000000000 \
b0 J
b0 (
b0 U
b0 j
b0 i
b1001 `
b1001 e
b1000 d
b0 D
b1000010010000000000000000 "
b1000010010000000000000000 0
b1000010010000000000000000 N
b1000010010000000000000000 Q
b10000 2
b10000 [
b10000 -
b10000 ]
b1100 !
b1100 .
b1100 ?
b10000 M
b10000 T
b1100 O
b1100 P
b1100 S
1%
#50
0%
#55
b100110010000000000000001000 /
b100110010000000000000001000 \
b10 J
b10 (
b10 U
b10 j
b10 i
b10010 `
b10010 e
b1001 d
b10100 ,
b10100 ^
b1001100100000000000000010 "
b1001100100000000000000010 0
b1001100100000000000000010 N
b1001100100000000000000010 Q
b10100 M
b10100 T
b10000 O
b10000 P
b10000 S
b11100 2
b11100 [
b10100 -
b10100 ]
b10000 !
b10000 .
b10000 ?
1%
#60
0%
#65
b11000 ,
b11000 ^
b101001011000000000000000100 /
b101001011000000000000000100 \
b1 J
b1 (
b1 U
b1 j
b1 i
b1011 `
b1011 e
b1010 d
b1010010110000000000000001 "
b1010010110000000000000001 0
b1010010110000000000000001 N
b1010010110000000000000001 Q
b11100 2
b11100 [
b11000 -
b11000 ]
b10100 !
b10100 .
b10100 ?
b11000 M
b11000 T
b10100 O
b10100 P
b10100 S
1%
#70
0%
#75
b101001011000000000000000000 /
b101001011000000000000000000 \
b0 J
b0 (
b0 U
b0 j
b0 i
b11100 ,
b11100 ^
b1010010110000000000000000 "
b1010010110000000000000000 0
b1010010110000000000000000 N
b1010010110000000000000000 Q
b11100 M
b11100 T
b11000 O
b11000 P
b11000 S
b11100 2
b11100 [
b11100 -
b11100 ]
b11000 !
b11000 .
b11000 ?
1%
#80
0%
#85
b100000 ,
b100000 ^
b101001011000000000000001000 /
b101001011000000000000001000 \
b10 J
b10 (
b10 U
b10 j
b10 i
b1010010110000000000000010 "
b1010010110000000000000010 0
b1010010110000000000000010 N
b1010010110000000000000010 Q
b101000 2
b101000 [
b100000 -
b100000 ]
b11100 !
b11100 .
b11100 ?
b100000 M
b100000 T
b11100 O
b11100 P
b11100 S
1%
#90
0%
#95
b101001011000000000000001100 /
b101001011000000000000001100 \
b11 J
b11 (
b11 U
b11 j
b11 i
b100100 ,
b100100 ^
b1010010110000000000000011 "
b1010010110000000000000011 0
b1010010110000000000000011 N
b1010010110000000000000011 Q
b100100 M
b100100 T
b100000 O
b100000 P
b100000 S
b110000 2
b110000 [
b100100 -
b100100 ]
b100000 !
b100000 .
b100000 ?
1%
#100
0%
#105
b101000 ,
b101000 ^
b101001011000000000000010000 /
b101001011000000000000010000 \
b100 J
b100 (
b100 U
b100 j
b100 i
b1010010110000000000000100 "
b1010010110000000000000100 0
b1010010110000000000000100 N
b1010010110000000000000100 Q
b111000 2
b111000 [
b101000 -
b101000 ]
b100100 !
b100100 .
b100100 ?
b101000 M
b101000 T
b100100 O
b100100 P
b100100 S
1%
#110
0%
#115
bx '
bx Z
bx f
x#
bx $
bx <
bx B
bx I
bx X
b10 >
b10 G
b10 L
bx 4
bx a
bx g
bx 1
bx F
bx W
b0 =
b0 E
b0 K
03
05
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 /
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 \
bx J
bx (
bx U
bx j
bx i
bx _
bx `
bx )
bx @
bx V
bx c
bx e
bx *
bx H
bx b
bx d
bx D
b101100 ,
b101100 ^
bx "
bx 0
bx N
bx Q
b101100 M
b101100 T
b101000 O
b101000 P
b101000 S
bx 2
bx [
b101100 -
b101100 ]
b101000 !
b101000 .
b101000 ?
1%
#120
0%
#125
b110000 ,
b110000 ^
b110000 -
b110000 ]
b101100 !
b101100 .
b101100 ?
b110000 M
b110000 T
b101100 O
b101100 P
b101100 S
1%
#130
0%
#135
b110100 ,
b110100 ^
b110100 M
b110100 T
b110000 O
b110000 P
b110000 S
b110100 -
b110100 ]
b110000 !
b110000 .
b110000 ?
1%
#140
0%
#145
b111000 ,
b111000 ^
b111000 -
b111000 ]
b110100 !
b110100 .
b110100 ?
b111000 M
b111000 T
b110100 O
b110100 P
b110100 S
1%
#150
0%
#155
b111100 ,
b111100 ^
b111100 M
b111100 T
b111000 O
b111000 P
b111000 S
b111100 -
b111100 ]
b111000 !
b111000 .
b111000 ?
1%
#160
0%
#165
b1000000 ,
b1000000 ^
b1000000 -
b1000000 ]
b111100 !
b111100 .
b111100 ?
b1000000 M
b1000000 T
b111100 O
b111100 P
b111100 S
1%
#170
0%
#175
b1000100 ,
b1000100 ^
b1000100 M
b1000100 T
b1000000 O
b1000000 P
b1000000 S
b1000100 -
b1000100 ]
b1000000 !
b1000000 .
b1000000 ?
1%
#180
0%
#185
b1001000 ,
b1001000 ^
b1001000 -
b1001000 ]
b1000100 !
b1000100 .
b1000100 ?
b1001000 M
b1001000 T
b1000100 O
b1000100 P
b1000100 S
1%
#190
0%
#195
b1001100 ,
b1001100 ^
b1001100 M
b1001100 T
b1001000 O
b1001000 P
b1001000 S
b1001100 -
b1001100 ]
b1001000 !
b1001000 .
b1001000 ?
1%
#200
0%
