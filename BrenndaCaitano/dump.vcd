$date
	Sun Feb 09 21:29:42 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 # pc_src $end
$var wire 1 " reset $end
$var wire 1 $ zero_flag $end
$var wire 5 % write_reg [4:0] $end
$var wire 32 & write_back_data [31:0] $end
$var wire 32 ' sign_ext_imm [31:0] $end
$var wire 1 ( reg_write $end
$var wire 1 ) reg_dst $end
$var wire 32 * reg_data2 [31:0] $end
$var wire 32 + reg_data1 [31:0] $end
$var wire 32 , pc_plus4 [31:0] $end
$var wire 32 - pc_next [31:0] $end
$var wire 32 . pc_jump [31:0] $end
$var wire 32 / pc_current [31:0] $end
$var wire 32 0 pc_branch [31:0] $end
$var wire 1 1 mem_write $end
$var wire 1 2 mem_to_reg $end
$var wire 32 3 mem_read_data [31:0] $end
$var wire 1 4 mem_read $end
$var wire 32 5 jump_address [31:0] $end
$var wire 1 6 jump $end
$var wire 32 7 instr [31:0] $end
$var wire 1 8 branch $end
$var wire 32 9 alu_src_b [31:0] $end
$var wire 1 : alu_src $end
$var wire 32 ; alu_result [31:0] $end
$var wire 2 < alu_op [1:0] $end
$var wire 3 = alu_control_signal [2:0] $end
$scope module alu_ctrl $end
$var wire 6 > funct [5:0] $end
$var wire 2 ? alu_op [1:0] $end
$var reg 3 @ alu_control_signal [2:0] $end
$upscope $end
$scope module alu_src_mux $end
$var wire 1 : sel $end
$var wire 32 A out [31:0] $end
$var wire 32 B in1 [31:0] $end
$var wire 32 C in0 [31:0] $end
$var parameter 32 D WIDTH $end
$upscope $end
$scope module arithmetic_logic_unit $end
$var wire 3 E alu_control [2:0] $end
$var wire 32 F b [31:0] $end
$var wire 1 $ zero $end
$var wire 32 G a [31:0] $end
$var reg 32 H result [31:0] $end
$upscope $end
$scope module branch_adder $end
$var wire 32 I b [31:0] $end
$var wire 32 J out [31:0] $end
$var wire 32 K a [31:0] $end
$upscope $end
$scope module branch_mux $end
$var wire 32 L in1 [31:0] $end
$var wire 1 # sel $end
$var wire 32 M out [31:0] $end
$var wire 32 N in0 [31:0] $end
$var parameter 32 O WIDTH $end
$upscope $end
$scope module control_unit $end
$var wire 6 P opcode [5:0] $end
$var reg 2 Q alu_op [1:0] $end
$var reg 1 : alu_src $end
$var reg 1 8 branch $end
$var reg 1 6 jump $end
$var reg 1 4 mem_read $end
$var reg 1 2 mem_to_reg $end
$var reg 1 1 mem_write $end
$var reg 1 ) reg_dst $end
$var reg 1 ( reg_write $end
$upscope $end
$scope module data_memory $end
$var wire 32 R addr [31:0] $end
$var wire 1 ! clk $end
$var wire 1 1 mem_write $end
$var wire 32 S read_data [31:0] $end
$var wire 32 T write_data [31:0] $end
$upscope $end
$scope module instruction_memory $end
$var wire 32 U instr [31:0] $end
$var wire 32 V addr [31:0] $end
$upscope $end
$scope module jump_mux $end
$var wire 32 W in0 [31:0] $end
$var wire 1 6 sel $end
$var wire 32 X out [31:0] $end
$var wire 32 Y in1 [31:0] $end
$var parameter 32 Z WIDTH $end
$upscope $end
$scope module jump_shift $end
$var wire 26 [ address [25:0] $end
$var wire 32 \ pc_plus_4 [31:0] $end
$var wire 32 ] jump_address [31:0] $end
$upscope $end
$scope module mem_to_reg_mux $end
$var wire 32 ^ in0 [31:0] $end
$var wire 32 _ in1 [31:0] $end
$var wire 1 2 sel $end
$var wire 32 ` out [31:0] $end
$var parameter 32 a WIDTH $end
$upscope $end
$scope module pc_plus4_adder $end
$var wire 32 b b [31:0] $end
$var wire 32 c out [31:0] $end
$var wire 32 d a [31:0] $end
$upscope $end
$scope module program_counter $end
$var wire 1 ! clk $end
$var wire 32 e next_pc [31:0] $end
$var wire 1 " reset $end
$var reg 32 f current_pc [31:0] $end
$upscope $end
$scope module reg_dst_mux $end
$var wire 5 g in0 [4:0] $end
$var wire 5 h in1 [4:0] $end
$var wire 1 ) sel $end
$var wire 5 i out [4:0] $end
$var parameter 32 j WIDTH $end
$upscope $end
$scope module register_file $end
$var wire 1 ! clk $end
$var wire 32 k read_data1 [31:0] $end
$var wire 32 l read_data2 [31:0] $end
$var wire 5 m read_reg1 [4:0] $end
$var wire 5 n read_reg2 [4:0] $end
$var wire 1 ( reg_write $end
$var wire 32 o write_data [31:0] $end
$var wire 5 p write_reg [4:0] $end
$upscope $end
$scope module sign_extension $end
$var wire 16 q imm [15:0] $end
$var wire 32 r ext_imm [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b101 j
b100000 a
b100000 Z
b100000 O
b100000 D
$end
#0
$dumpvars
bx r
bx q
bx p
bx o
bx n
bx m
bx l
bx k
bx i
bx h
bx g
b0 f
bx e
b0 d
b100 c
b100 b
bx `
bx _
bx ^
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 ]
b100 \
bx [
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 Y
bx X
bx W
b0 V
bx U
bx T
bx S
bx R
bx Q
bx P
b100 N
bx M
bx L
b100 K
bx J
bx00 I
bx H
bx G
bx F
bx E
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
x:
bx 9
x8
bx 7
x6
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 5
x4
bx 3
x2
x1
bx 0
b0 /
bx .
bx -
b100 ,
bx +
bx *
x)
x(
bx '
bx &
bx %
x$
x#
1"
0!
$end
#5
1!
#10
0!
0"
#15
bx00 5
bx00 Y
bx00 ]
bx ,
bx K
bx N
bx \
bx c
bx /
bx V
bx d
bx f
1!
#20
0!
#25
1!
#30
0!
#35
1!
#40
0!
#45
1!
#50
0!
#55
1!
#60
0!
#65
1!
#70
0!
#75
1!
#80
0!
#85
1!
#90
0!
#95
1!
#100
0!
#105
1!
#110
0!
#115
1!
#120
0!
#125
1!
#130
0!
#135
1!
#140
0!
#145
1!
#150
0!
#155
1!
#160
0!
#165
1!
#170
0!
#175
1!
#180
0!
#185
1!
#190
0!
#195
1!
#200
0!
#205
1!
#210
0!
