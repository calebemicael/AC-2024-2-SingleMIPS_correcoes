$date
	Sun Apr  6 12:39:02 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module TesteMIPS $end
$var reg 1 ! clock $end
$var reg 1 " reset $end
$scope module processador $end
$var wire 1 # FontePC $end
$var wire 1 ! clock $end
$var wire 1 " reset $end
$var wire 32 $ resultado_alu [31:0] $end
$var wire 5 % reg_escrita [4:0] $end
$var wire 32 & pc_proximo [31:0] $end
$var wire 32 ' pc_mais4 [31:0] $end
$var wire 32 ( pc_desvio [31:0] $end
$var wire 32 ) instrucao [31:0] $end
$var wire 32 * extendido_sinal [31:0] $end
$var wire 32 + entrada_b_alu [31:0] $end
$var wire 32 , endereco_deslocado [31:0] $end
$var wire 32 - dado_leitura_mem [31:0] $end
$var wire 32 . dado_leitura2 [31:0] $end
$var wire 32 / dado_leitura1 [31:0] $end
$var wire 32 0 dado_escrita_reg [31:0] $end
$var wire 1 1 Zero $end
$var wire 1 2 RegWrite $end
$var wire 1 3 RegDst $end
$var wire 1 4 MemtoReg $end
$var wire 1 5 MemWrite $end
$var wire 1 6 MemRead $end
$var wire 1 7 Branch $end
$var wire 1 8 ALUSrc $end
$var wire 4 9 ALUOperation [3:0] $end
$var wire 2 : ALUOp [1:0] $end
$var reg 32 ; pc [31:0] $end
$scope module alu $end
$var wire 1 1 Zero $end
$var wire 32 < B [31:0] $end
$var wire 4 = ALUOperation [3:0] $end
$var wire 32 > A [31:0] $end
$var reg 32 ? ALUResult [31:0] $end
$upscope $end
$scope module controle $end
$var wire 6 @ opcode [5:0] $end
$var reg 2 A ALUOp [1:0] $end
$var reg 1 8 ALUSrc $end
$var reg 1 7 Branch $end
$var reg 1 6 MemRead $end
$var reg 1 5 MemWrite $end
$var reg 1 4 MemtoReg $end
$var reg 1 3 RegDst $end
$var reg 1 2 RegWrite $end
$upscope $end
$scope module controle_alu $end
$var wire 2 B ALUOp [1:0] $end
$var wire 6 C funct [5:0] $end
$var reg 4 D ALUOperation [3:0] $end
$upscope $end
$scope module desloca_esquerda_2 $end
$var wire 32 E out [31:0] $end
$var wire 32 F in [31:0] $end
$upscope $end
$scope module extensor_sinal $end
$var wire 16 G in [15:0] $end
$var wire 32 H out [31:0] $end
$upscope $end
$scope module memoria_dados $end
$var wire 1 6 MemRead $end
$var wire 1 5 MemWrite $end
$var wire 32 I address [31:0] $end
$var wire 1 ! clk $end
$var wire 32 J writeData [31:0] $end
$var wire 32 K readData [31:0] $end
$var integer 32 L i [31:0] $end
$upscope $end
$scope module memoria_instrucoes $end
$var wire 32 M addr [31:0] $end
$var wire 32 N instrucao [31:0] $end
$upscope $end
$scope module mux_fonte_alu $end
$var wire 32 O in1 [31:0] $end
$var wire 1 8 sel $end
$var wire 32 P out [31:0] $end
$var wire 32 Q in0 [31:0] $end
$upscope $end
$scope module mux_fonte_pc $end
$var wire 1 # sel $end
$var wire 32 R out [31:0] $end
$var wire 32 S in1 [31:0] $end
$var wire 32 T in0 [31:0] $end
$upscope $end
$scope module mux_mem_para_reg $end
$var wire 32 U in0 [31:0] $end
$var wire 32 V in1 [31:0] $end
$var wire 1 4 sel $end
$var wire 32 W out [31:0] $end
$upscope $end
$scope module mux_reg_dst $end
$var wire 5 X in0 [4:0] $end
$var wire 5 Y in1 [4:0] $end
$var wire 1 3 sel $end
$var wire 5 Z out [4:0] $end
$upscope $end
$scope module registradores $end
$var wire 32 [ ReadData1 [31:0] $end
$var wire 32 \ ReadData2 [31:0] $end
$var wire 5 ] ReadRegister1 [4:0] $end
$var wire 5 ^ ReadRegister2 [4:0] $end
$var wire 1 2 RegWrite $end
$var wire 32 _ WriteData [31:0] $end
$var wire 5 ` WriteRegister [4:0] $end
$var integer 32 a i [31:0] $end
$upscope $end
$scope module soma_pc $end
$var wire 32 b in [31:0] $end
$var wire 32 c out [31:0] $end
$upscope $end
$scope module somador_desvio $end
$var wire 32 d a [31:0] $end
$var wire 32 e b [31:0] $end
$var wire 32 f sum [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b1000 f
b100 e
b100 d
b100 c
b0 b
b100000 a
b0 `
b0 _
b0 ^
b0 ]
b0 \
b0 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b100 T
b1000 S
b100 R
b0 Q
b0 P
b1 O
b1 N
b0 M
b100000000 L
b0 K
b0 J
b0 I
b1 H
b1 G
b1 F
b100 E
b0 D
b1 C
b10 B
b10 A
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b10 :
b0 9
08
07
06
05
04
13
12
11
b0 0
b0 /
b0 .
b0 -
b100 ,
b0 +
b1 *
b1 )
b1000 (
b100 '
b100 &
b0 %
b0 $
0#
1"
0!
$end
#5
1!
#10
0!
0"
#15
b0 ,
b0 E
b0 e
b0 C
b0 *
b0 F
b0 H
b0 O
b0 G
b0 )
b0 N
b1000 &
b1000 R
b1000 (
b1000 S
b1000 f
b1000 '
b1000 T
b1000 c
b1000 d
b100 ;
b100 M
b100 b
1!
#20
0!
#25
b1100 &
b1100 R
b1100 (
b1100 S
b1100 f
b1100 '
b1100 T
b1100 c
b1100 d
b1000 ;
b1000 M
b1000 b
1!
#30
0!
#35
b10000000000 ,
b10000000000 E
b10000000000 e
b100000000 *
b100000000 F
b100000000 H
b100000000 O
b100000000 G
b100000000 )
b100000000 N
b10000 &
b10000 R
b10000010000 (
b10000010000 S
b10000010000 f
b10000 '
b10000 T
b10000 c
b10000 d
b1100 ;
b1100 M
b1100 b
1!
#40
0!
#45
b0 ,
b0 E
b0 e
b0 *
b0 F
b0 H
b0 O
b0 G
b10000 ^
b10000 X
b100000000000000000000 )
b100000000000000000000 N
b10100 &
b10100 R
b10100 (
b10100 S
b10100 f
b10100 '
b10100 T
b10100 c
b10100 d
b10000 ;
b10000 M
b10000 b
1!
#50
0!
#55
b10000000100 ,
b10000000100 E
b10000000100 e
b1 C
b100000001 *
b100000001 F
b100000001 H
b100000001 O
b100000001 G
b0 ^
b0 X
b100000001 )
b100000001 N
b11000 &
b11000 R
b10000011100 (
b10000011100 S
b10000011100 f
b11000 '
b11000 T
b11000 c
b11000 d
b10100 ;
b10100 M
b10100 b
1!
#60
0!
#65
b100 ,
b100 E
b100 e
b1 *
b1 F
b1 H
b1 O
b1 G
b1 )
b1 N
b11100 &
b11100 R
b100000 (
b100000 S
b100000 f
b11100 '
b11100 T
b11100 c
b11100 d
b11000 ;
b11000 M
b11000 b
1!
#70
0!
#75
b0 ,
b0 E
b0 e
b0 C
b0 *
b0 F
b0 H
b0 O
b0 G
b1 ^
b1 X
b10000000000000000 )
b10000000000000000 N
b100000 &
b100000 R
b100000 (
b100000 S
b100000 f
b100000 '
b100000 T
b100000 c
b100000 d
b11100 ;
b11100 M
b11100 b
1!
#80
0!
#85
b0 ^
b0 X
b0 )
b0 N
b100100 &
b100100 R
b100100 (
b100100 S
b100100 f
b100100 '
b100100 T
b100100 c
b100100 d
b100000 ;
b100000 M
b100000 b
1!
#90
0!
#95
b101000 &
b101000 R
b101000 (
b101000 S
b101000 f
b101000 '
b101000 T
b101000 c
b101000 d
b100100 ;
b100100 M
b100100 b
1!
#100
0!
#105
b100 ,
b100 E
b100 e
b1 C
b1 *
b1 F
b1 H
b1 O
b1 G
b1 )
b1 N
b101100 &
b101100 R
b110000 (
b110000 S
b110000 f
b101100 '
b101100 T
b101100 c
b101100 d
b101000 ;
b101000 M
b101000 b
1!
#110
0!
#115
b110000 &
b110000 R
b110100 (
b110100 S
b110100 f
b110000 '
b110000 T
b110000 c
b110000 d
b101100 ;
b101100 M
b101100 b
1!
#120
0!
#125
b110100 &
b110100 R
b111000 (
b111000 S
b111000 f
b110100 '
b110100 T
b110100 c
b110100 d
b110000 ;
b110000 M
b110000 b
1!
#130
0!
#135
b100000001000000 ,
b100000001000000 E
b100000001000000 e
b10 %
b10 Z
b10 `
b10000 C
b1000000010000 *
b1000000010000 F
b1000000010000 H
b1000000010000 O
b1000000010000 G
b10 Y
b1000000010000 )
b1000000010000 N
b111000 &
b111000 R
b100000001111000 (
b100000001111000 S
b100000001111000 f
b111000 '
b111000 T
b111000 c
b111000 d
b110100 ;
b110100 M
b110100 b
1!
#140
0!
#145
b100010000000000 ,
b100010000000000 E
b100010000000000 e
b0 C
b1000100000000 *
b1000100000000 F
b1000100000000 H
b1000100000000 O
b1000100000000 G
b1000100000000 )
b1000100000000 N
b111100 &
b111100 R
b100010000111100 (
b100010000111100 S
b100010000111100 f
b111100 '
b111100 T
b111100 c
b111100 d
b111000 ;
b111000 M
b111000 b
1!
#150
0!
#155
x1
bx 0
bx W
bx _
bx $
bx ?
bx I
bx U
b10 9
b10 =
b10 D
bx00 ,
bx00 E
bx00 e
bx +
bx <
bx P
bx %
bx Z
bx `
b0 :
b0 A
b0 B
02
03
bx C
bx *
bx F
bx H
bx O
bx G
bx .
bx J
bx Q
bx \
bx ^
bx /
bx >
bx [
bx ]
bx Y
bx X
bx @
bx )
bx N
b1000000 &
b1000000 R
bx (
bx S
bx f
b1000000 '
b1000000 T
b1000000 c
b1000000 d
b111100 ;
b111100 M
b111100 b
1!
#160
0!
#165
b1000100 &
b1000100 R
b1000100 '
b1000100 T
b1000100 c
b1000100 d
b1000000 ;
b1000000 M
b1000000 b
1!
#170
0!
#175
b1001000 &
b1001000 R
b1001000 '
b1001000 T
b1001000 c
b1001000 d
b1000100 ;
b1000100 M
b1000100 b
1!
#180
0!
#185
b1001100 &
b1001100 R
b1001100 '
b1001100 T
b1001100 c
b1001100 d
b1001000 ;
b1001000 M
b1001000 b
1!
#190
0!
#195
b1010000 &
b1010000 R
b1010000 '
b1010000 T
b1010000 c
b1010000 d
b1001100 ;
b1001100 M
b1001100 b
1!
#200
0!
#205
b1010100 &
b1010100 R
b1010100 '
b1010100 T
b1010100 c
b1010100 d
b1010000 ;
b1010000 M
b1010000 b
1!
#210
0!
