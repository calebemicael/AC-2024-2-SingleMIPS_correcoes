$date
	Sun Apr  6 17:07:30 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module mips_tb $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 # zero $end
$var wire 5 $ write_reg [4:0] $end
$var wire 32 % write_data [31:0] $end
$var wire 32 & sign_extended [31:0] $end
$var wire 32 ' shifted_immediate [31:0] $end
$var wire 5 ( rt [4:0] $end
$var wire 5 ) rs [4:0] $end
$var wire 32 * read_data2 [31:0] $end
$var wire 32 + read_data1 [31:0] $end
$var wire 5 , rd [4:0] $end
$var wire 32 - pc_plus_4 [31:0] $end
$var wire 32 . pc_next [31:0] $end
$var wire 32 / pc_current [31:0] $end
$var wire 6 0 opcode [5:0] $end
$var wire 32 1 mem_to_reg_mux_out [31:0] $end
$var wire 32 2 instruction [31:0] $end
$var wire 16 3 immediate [15:0] $end
$var wire 6 4 funct [5:0] $end
$var wire 32 5 branch_address [31:0] $end
$var wire 1 6 RegWrite $end
$var wire 1 7 RegDst $end
$var wire 1 8 MemtoReg $end
$var wire 1 9 MemWrite $end
$var wire 1 : MemRead $end
$var wire 1 ; Branch $end
$var wire 32 < ALU_srcB [31:0] $end
$var wire 32 = ALU_result [31:0] $end
$var wire 4 > ALU_Ctrl [3:0] $end
$var wire 1 ? ALUSrc $end
$var wire 2 @ ALUOp [1:0] $end
$scope module alu $end
$var wire 1 # zero $end
$var wire 32 A input2 [31:0] $end
$var wire 32 B input1 [31:0] $end
$var wire 4 C aluControl [3:0] $end
$var reg 32 D result [31:0] $end
$upscope $end
$scope module alu_control $end
$var wire 6 E funct [5:0] $end
$var wire 2 F ALUOp [1:0] $end
$var reg 4 G ALU_Ctrl [3:0] $end
$upscope $end
$scope module alu_src_mux $end
$var wire 1 ? sel $end
$var wire 32 H out [31:0] $end
$var wire 32 I in1 [31:0] $end
$var wire 32 J in0 [31:0] $end
$upscope $end
$scope module branch_adder $end
$var wire 32 K result [31:0] $end
$var wire 32 L b [31:0] $end
$var wire 32 M a [31:0] $end
$upscope $end
$scope module control $end
$var wire 6 N opcode [5:0] $end
$var reg 2 O ALUOp [1:0] $end
$var reg 1 ? ALUSrc $end
$var reg 1 ; Branch $end
$var reg 1 : MemRead $end
$var reg 1 9 MemWrite $end
$var reg 1 8 MemtoReg $end
$var reg 1 7 RegDst $end
$var reg 1 6 RegWrite $end
$upscope $end
$scope module data_mem $end
$var wire 32 P address [31:0] $end
$var wire 1 ! clk $end
$var wire 1 : memRead $end
$var wire 1 9 memWrite $end
$var wire 32 Q writeData [31:0] $end
$var wire 32 R readData [31:0] $end
$upscope $end
$scope module instr_mem $end
$var wire 32 S instruction [31:0] $end
$var wire 32 T address [31:0] $end
$upscope $end
$scope module mem_to_reg_mux $end
$var wire 32 U in0 [31:0] $end
$var wire 32 V in1 [31:0] $end
$var wire 1 8 sel $end
$var wire 32 W out [31:0] $end
$upscope $end
$scope module pc_adder $end
$var wire 32 X b [31:0] $end
$var wire 32 Y result [31:0] $end
$var wire 32 Z a [31:0] $end
$upscope $end
$scope module pc_mux $end
$var wire 1 ; branch $end
$var wire 32 [ branch_address [31:0] $end
$var wire 32 \ pc_plus_4 [31:0] $end
$var wire 1 # zero $end
$var wire 32 ] next_pc [31:0] $end
$upscope $end
$scope module pc_reg $end
$var wire 1 ! clk $end
$var wire 32 ^ pc_in [31:0] $end
$var wire 1 " reset $end
$var reg 32 _ pc_out [31:0] $end
$upscope $end
$scope module reg_dst_mux $end
$var wire 5 ` in0 [4:0] $end
$var wire 5 a in1 [4:0] $end
$var wire 1 7 sel $end
$var wire 5 b out [4:0] $end
$upscope $end
$scope module reg_file $end
$var wire 1 ! clk $end
$var wire 32 c readData1 [31:0] $end
$var wire 32 d readData2 [31:0] $end
$var wire 5 e readReg1 [4:0] $end
$var wire 5 f readReg2 [4:0] $end
$var wire 1 6 regWrite $end
$var wire 32 g writeData [31:0] $end
$var wire 5 h writeReg [4:0] $end
$upscope $end
$scope module shift_left_2 $end
$var wire 32 i out [31:0] $end
$var wire 32 j in [31:0] $end
$upscope $end
$scope module sign_ext $end
$var wire 16 k in [15:0] $end
$var wire 32 l out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx l
bx k
bx j
bx00 i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
b0 _
bx ^
bx ]
b100 \
bx [
b0 Z
b100 Y
b100 X
bx W
bx V
bx U
b0 T
bx S
bx R
bx Q
bx P
bx O
bx N
b100 M
bx00 L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
x?
bx >
bx =
bx <
x;
x:
x9
x8
x7
x6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
b0 /
bx .
b100 -
bx ,
bx +
bx *
bx )
bx (
bx00 '
bx &
bx %
bx $
x#
1"
0!
$end
#5000
1!
#10000
0!
0"
#15000
bx -
bx M
bx Y
bx \
bx /
bx T
bx Z
bx _
1!
#20000
0!
#25000
1!
#30000
0!
#35000
1!
#40000
0!
#45000
1!
#50000
0!
#55000
1!
#60000
0!
#65000
1!
#70000
0!
#75000
1!
#80000
0!
#85000
1!
#90000
0!
#95000
1!
#100000
0!
#105000
1!
#110000
0!
